//ff-mpirun -np 8 Helmholtz-2d-plane-wave-strips.edp -wg -raspart -ffddm_schwarz_method oras -ffddm_partitioner 0 -nloc 20 -waven 18.5 -absorp 18.5 -ffddm_overlap 2 -ffddm_gmres_restart 1000
// Use -ffddm_disable_plots for surpressing plots

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

macro dimension 2// EOM            // 2D or 3D

include "ffddm.idp"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P1;

// Waveguide problem with strips and plane-wave incident from the left
// Problem parameters
real k = getARGV("-waven",18.5);
real c = 1.;
func f = 0; // 100*exp(-((x-.5)^2+(y-.5)^2)*k*10);
real d1 = 1, d2 = 0; // direction of incomming wave
func Nx = N.x;
func Ny = N.y;
func gn = 1i*k*(d1*Nx+d2*Ny +1)*exp(1i*k*(d1*x+d2*y)); // Robin BC
// Boundary conditions
int Dirichlet = 1;
int Robin = 2;
int[int] chlab=[1, Dirichlet, 2, Robin, 3, Dirichlet, 4, Robin];
// Create mesh
int nsubdom = 5;
int nloc = getARGV("-nloc",20);
mesh Thc = square(ffddmnpart*nsubdom,nsubdom,[ffddmnpart*x,y],flags=0);
Thc = change(Thc,refe=chlab);
mesh Th = trunc(Thc,1,split=nloc);
// Uniform partitioning (if using -ffddm_partitioner 0)
macro Hmeshsimple(Ph,upart,comm)
  int nn = ffddmnpart;
  Ph xx=x;
  upart = int(xx*nn)/nn;
// EOM

// Absorption parameters
real epsilonprob = getARGV("-absorp",k);
real epsilonEprec = epsilonprob;

macro Grad(u) [dx(u),dy(u)] // EOM

// Variational forms:
macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  intN(meshName)(-(k^2-1i*epsilonprob)/(c^2)*u*v+Grad(u)'*Grad(v))
				+ intbN(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfPrec(varfName, meshName, PhName)
    varf varfName(u,v) =
  intN(meshName)(-(k^2-1i*epsilonEprec)/(c^2)*u*v+Grad(u)'*Grad(v))
				+ intbN(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
    varf varfName(u,v) =
  intN(meshName)(-(k^2-1i*epsilonEprec)/(c^2)*u*v+Grad(u)'*Grad(v))
				+ intbN(meshName,Robin,10)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                - intN(meshName)(f*v)
                + intbN(meshName,Robin)(1i*gn*v)
                + on(Dirichlet,u=0); // EOM

ffddmbuildDmesh(Hmesh,Th,mpiCommWorld)

if (mpiRank(Hmeshmpicomm) == 0)
  {
    cout << "Some ffddm options used:" << endl;
    cout << "  ffddmoverlap = " << ffddmoverlap << endl;
    cout << "  ffddmpartitioner = " << ffddmpartitioner << endl;
    cout << "  ffddmprecond = " << ffddmprecond << endl;
  }

ffddmbuildDfespace(HFE,Hmesh,complex,def,init,Pk)

// Plot wavespeed
// HFEVhi<real> cplot=c;
// ffddmplot(HFE,cplot,"Wavespeed c");

ffddmsetup(H,HFE,Varf,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(H,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

HFEVhi<complex> def(u), def(err);

if (mpirank == 0) cout << "ONE-LEVEL:" << endl;

u[] = HfGMRES(x0, rhs, 1.e-6, 1000, "right");

Hwritesummary

ffddmplot(HFE,real(u), "Global solution");
